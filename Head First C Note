gcc zork.c -o zork && ./zork
&& 表示「並且假如成功的話，就進行⋯⋯」

break 不能用來中斷 if 陳述式

串接指定
	x = 4 運算式本身也具有回傳值：4
	y = x = 4;
	把 x 和 y 都設定成 4

陣列變數當作指標使用
	doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]

字串實字（String literals）永遠不能被更新
	指向字串實字的變數不能用來改變該字串的內容
		char *cards = "JQK";
	如果從字串實字重新建立一個陣列，就“能夠”修改該陣列
		char card[] = "JQK";

記憶體存儲器（由高至低）
	1.Stack（堆疊）
		區域變數（local variables）
	2.Heap（堆積）
		動態記憶體（dynamic memory）
	3.Globals（全域區段）
	4.Constants（常數區段）
		唯讀
	5.Code（程式碼區段）
		唯讀

指標構成的陣列
	char* name_for_dog[] = {"Bowser", "Bonza", "Snodgrass"};
	每個字串實字都會有一個指標指向他

| 符號（管線）是將一個行程之標準輸出連結到另一個行程之標準輸入的符號
	(./bermuda | ./geo2json) < spooky.csv > output.json

P.149 有很多有趣的東西

struct指標表示法（t是指向struct的指標）
	(*t).age
	t->age
	這兩個表達式表達同一件事

strdup() 函式能夠在 heap 某處重新產生該字串的完整副本
	char *copy = strdup(s);
	strdup() 在 string.h 中，函式計算該字串多長，然後呼叫 malloc() 函式，在 heap 上配置正確數量的字元

指向函式的指標
	回傳類型(*指標變數)(參數型別)
	eg. char** (*names_fn)(char*, int)

P.330 要好好讀一下
P.338 也看不太懂
第七章蠻難的 可以好好研究一下


//以下內容取自https://dotblogs.com.tw/brian/2012/10/18/77588

指標的宣告
	int* p, q;

	不要把這行誤解成 p ， q 都是指向 int 之指標，事實上， q 只是一個 int 變數。上面這行相當於

	int *p, q; 或 int *p; int q;	

	如果 p ， q 都要宣告成指向int之指標，應寫成：

	int *p, *q;

	或者乾脆分兩行寫：

	int* p;
	int* q;

常數與指標的讀法
	關鍵在於： * 與 const 的前後關係!
	當 * 在 const 之前，則是常數指標，反之則為常數變數。因此，
	
	const double *ptr;    // ptr指向常數變數
	double *const ptr;    // ptr是常數指標
	double const* ptr;    // ptr指向常數變數
	const double *const ptr;    // 指向常數變數的常數指標
	
	事實上，在 The C++ Programming Language 中有提到一個簡單的要訣：由右向左讀!!讓我們用這個要訣再來試一次。
	
	const double *ptr;    // ptr is a pointer points to double, which is a constant
	double *const ptr;    // ptr is a constant pointer points to double
	double const* ptr;    // ptr is a pointer points to constant double
	const double *const ptr;    // ptr is a constant pointer points to double, which is a constant





