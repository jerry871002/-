gcc zork.c -o zork && ./zork
&& 表示「並且假如成功的話，就進行⋯⋯」

break 不能用來中斷 if 陳述式

串接指定
	x = 4 運算式本身也具有回傳值：4
	y = x = 4;
	把 x 和 y 都設定成 4

陣列變數當作指標使用
	doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]

字串實字（String literals）永遠不能被更新
	指向字串實字的變數不能用來改變該字串的內容
		char *cards = "JQK";
	如果從字串實字重新建立一個陣列，就「能夠」修改該陣列
		char card[] = "JQK";

記憶體存儲器（由高至低）
	1.Stack（堆疊）
		區域變數（local variables）
	2.Heap（堆積）
		動態記憶體（dynamic memory）
	3.Globals（全域區段）
	4.Constants（常數區段）
		唯讀
	5.Code（程式碼區段）
		唯讀

指標構成的陣列
	char* name_for_dog[] = {"Bowser", "Bonza", "Snodgrass"};
	每個字串實字都會有一個指標指向他

| 符號（管線）是將一個行程之標準輸出連結到另一個行程之標準輸入的符號
	(./bermuda | ./geo2json) < spooky.csv > output.json

P.149 有很多有趣的東西

struct指標表示法（t是指向struct的指標）
	(*t).age
	t->age
	這兩個表達式表達同一件事

strdup() 函式能夠在 heap 某處重新產生該字串的完整副本
	char *copy = strdup(s);
	strdup() 在 string.h 中，函式計算該字串多長，然後呼叫 malloc() 函式，在 heap 上配置正確數量的字元

指向函式的指標
	回傳類型(*指標變數)(參數型別)
	e.g. char** (*names_fn)(char*, int)

	舉個小小的例子
		int (*wrap_fn)(int);
		wrap_fn = go_to_wrap_speed; //儲存go_to_wrap_speed()函式的位址
		wrap_fn(4); //這就跟呼叫go_to_wrap_speed(4)函式一樣

排序函式（sort function）與比較器函式（comparator function）
	在 stdlib.h 裡面有一個 qsort() 函式，看起來長這樣
	qsort(void array, //指向陣列的指標
		  size_t length, //該陣列的長度
		  size_t item_size, //陣列裡每個元素的尺寸
		  int (*compar)(const void *, const void *)); //指向比較陣列裡頭兩個項目的函式
	示範的程式放在資料夾 qsort_with_comparator 裡面

函式指標陣列
	回傳類型(*指標變數[])(參數型別)
	e.g. void (*replies[])(response) = {dump, second_chance, marriage}; //陣列裡面存放指向函式的指標
	範例程式在 mail_merge 裡面

可變參數函式（Variadic function）
	直接來個範例：

	#include <stdarg.h> //處理可變參數函式的程式碼都在這

	void print_ints(int args, ...) { //「...」被稱作「省略」（ellipsis），告訴你後面還有東西
		va_list ap; //va_list 用來儲存要傳進你的函式的額外引數
		va_start(ap, args); //va_start 指名可變動引數從哪裡開始
		for(int i = 0; i < args; i++) 
			printf("argument: %d\n", va_arg(ap, int)); //va_arg 接受兩個值：va_list 和下一個引數的「型別」
		va_end(ap); //讀完之後記得要結束
	}

	//call the function
	print_ints(3, 79, 101, 32);
	print_ints(2, 10, 2);

	小提示
	1.va_end、va_start 等東西實際上是巨集，不是函式
	2.至少要有一個固定參數
	3.如果嘗試讀取比傳進來的還要多的引數，會發生隨機錯誤（random error）


P.330 要好好讀一下
P.338 也看不太懂
第七章蠻難的 可以好好研究一下








