gcc zork.c -o zork && ./zork
&& 表示「並且假如成功的話，就進行⋯⋯」

break 不能用來中斷 if 陳述式

串接指定
	x = 4 運算式本身也具有回傳值：4
	y = x = 4;
	把 x 和 y 都設定成 4

陣列變數當作指標使用
	doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]

字串實字（String literals）永遠不能被更新
	指向字串實字的變數不能用來改變該字串的內容
		char *cards = "JQK";
	如果從字串實字重新建立一個陣列，就“能夠”修改該陣列
		char card[] = "JQK";

記憶體存儲器（由高至低）
	1.Stack（堆疊）
		區域變數（local variables）
	2.Heap（堆積）
		動態記憶體（dynamic memory）
	3.Globals（全域區段）
	4.Constants（常數區段）
		唯讀
	5.Code（程式碼區段）
		唯讀

指標構成的陣列
	char* name_for_dog[] = {"Bowser", "Bonza", "Snodgrass"};
	每個字串實字都會有一個指標指向他

| 符號（管線）是將一個行程之標準輸出連結到另一個行程之標準輸入的符號
	(./bermuda | ./geo2json) < spooky.csv > output.json

P.149 有很多有趣的東西

struct指標表示法（t是指向struct的指標）
	(*t).age
	t->age
	這兩個表達式表達同一件事

strdup() 函式能夠在 heap 某處重新產生該字串的完整副本
	char *copy = strdup(s);
	strdup() 在 string.h 中，函式計算該字串多長，然後呼叫 malloc() 函式，在 heap 上配置正確數量的字元

指向函式的指標
	回傳類型(*指標變數)(參數型別)
	eg. char** (*names_fn)(char*, int)

排序函式（sort function）與比較器函式（comparator function）
	在 stdlib.h 裡面有一個 qsort() 函式，看起來長這樣
	qsort(void array, //指向陣列的指標
		  size_t length, //該陣列的長度
		  size_t item_size, //陣列裡每個元素的尺寸
		  int (*compar)(const void *, const void *)); //指向比較陣列裡頭兩個項目的函式
	示範的程式放在資料夾 qsort_with_comparator 裡面

P.330 要好好讀一下
P.338 也看不太懂
第七章蠻難的 可以好好研究一下








